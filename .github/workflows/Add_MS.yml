name: Add Namespace and Microservice to Cluster

on:
  workflow_dispatch:
    inputs:
      cluster_name:
        description: 'Selecciona el cluster'
        required: true
        type: choice
        options:
          - PDCOLClusterEA01
          - PDCOLClusterEA02
          - PDCOLClusterPosWebEA
          - PDMEXClusterEA
          - PDPTCOLClusterEA
          - QACOLClusterEA
          - QACOLClusterEA02
          - QACOLClusterPosWebEA
          - QAMEXClusterEA
          - QAPTCOLClusterEA
          - STCOLClusterEA
          - STMEXClusterEA
          - STPTCOLClusterEA
          - SiigoAcademico80sCluster
        default: PDCOLClusterEA01
      namespace:
        description: 'Nombre del namespace (ej: siigo-addons)'
        required: true
        type: string
        default: 'siigo-'
      microservice:
        description: 'Nombre del microservicio (ej: api-gateway-addons)'
        required: true
        type: string
        default: 'api-gateway-'

jobs:
  add-namespace-microservice:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Validate cluster file exists
      id: validate_cluster
      run: |
        CLUSTER_FILE=".github/Utils/ms-per-cluster/${{ inputs.cluster_name }}.json"
        if [ ! -f "$CLUSTER_FILE" ]; then
          echo "❌ Error: El archivo $CLUSTER_FILE no existe"
          echo "Clusters disponibles:"
          ls -la .github/Utils/ms-per-cluster/*.json | awk -F'/' '{print $NF}' | sed 's/.json$//' || echo "No se encontraron archivos JSON"
          exit 1
        fi
        echo "✅ Cluster file found: $CLUSTER_FILE"
        echo "📁 Procesando cluster: ${{ inputs.cluster_name }}"
        echo "cluster_file=$CLUSTER_FILE" >> $GITHUB_OUTPUT
    
    - name: Backup original file
      run: |
        cp "${{ steps.validate_cluster.outputs.cluster_file }}" "${{ steps.validate_cluster.outputs.cluster_file }}.backup"
    
    - name: Add namespace and microservice
      id: update_json
      run: |
        CLUSTER_FILE="${{ steps.validate_cluster.outputs.cluster_file }}"
        NAMESPACE="${{ inputs.namespace }}"
        MICROSERVICE="${{ inputs.microservice }}"
        
        # Crear script de Python para manipular el JSON
        cat > update_json.py << 'EOF'
        import json
        import sys
        import os
        from collections import OrderedDict
        
        def main():
            if len(sys.argv) != 4:
                print("❌ Error: Se requieren 3 argumentos: cluster_file, namespace, microservice")
                sys.exit(1)
            
            cluster_file = sys.argv[1]
            namespace = sys.argv[2]
            new_microservice = sys.argv[3]
            
            try:
                # Leer el archivo JSON
                with open(cluster_file, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                # Verificar si el namespace ya existe
                if namespace in json_data:
                    existing_microservices = json_data[namespace]
                    print(f"⚠️  Namespace '{namespace}' ya existe con microservicios: '{existing_microservices}'")
                    
                    # Separar los microservicios existentes
                    if existing_microservices:
                        microservices_list = [ms.strip() for ms in existing_microservices.split(',')]
                    else:
                        microservices_list = []
                    
                    # Verificar si el microservicio ya existe
                    if new_microservice in microservices_list:
                        print(f"ℹ️  El microservicio '{new_microservice}' ya existe en el namespace '{namespace}'")
                        print("No se realizarán cambios.")
                        return
                    
                    # Agregar el nuevo microservicio a la lista
                    microservices_list.append(new_microservice)
                    
                    # Ordenar los microservicios alfabéticamente
                    microservices_list.sort(key=str.lower)
                    
                    # Crear la cadena de microservicios separada por comas
                    updated_microservices = ', '.join(microservices_list)
                    
                    print(f"➕ Agregando '{new_microservice}' a la lista existente")
                    print(f"📝 Lista actualizada: '{updated_microservices}'")
                    
                    # Actualizar el namespace con la lista completa
                    json_data[namespace] = updated_microservices
                else:
                    # Si el namespace no existe, simplemente agregarlo
                    print(f"🆕 Creando nuevo namespace '{namespace}' con microservicio '{new_microservice}'")
                    json_data[namespace] = new_microservice
                
                # Ordenar alfabéticamente por namespace (clave)
                sorted_json = OrderedDict(sorted(json_data.items(), key=lambda x: x[0].lower()))
                
                # Escribir el archivo JSON actualizado (con formato bonito y orden alfabético)
                with open(cluster_file, 'w', encoding='utf-8') as f:
                    json.dump(sorted_json, f, indent=2, ensure_ascii=False)
                    f.write('\n')  # Agregar nueva línea al final
                
                print(f"✅ Namespace '{namespace}' procesado exitosamente")
                print(f"📁 Archivo actualizado: {cluster_file}")
                print(f"🔤 Datos ordenados alfabéticamente (namespaces y microservicios)")
                
                # Mostrar el contenido actualizado (solo los primeros y últimos elementos para no saturar)
                sorted_items = list(sorted_json.items())
                total_items = len(sorted_items)
                
                print(f'\n📋 Contenido actualizado ({total_items} namespaces):')
                if total_items <= 10:
                    # Si hay pocos elementos, mostrar todos
                    for ns, ms in sorted_items:
                        print(f'  "{ns}": "{ms}"')
                else:
                    # Si hay muchos elementos, mostrar los primeros 5 y últimos 5
                    print("  Primeros 5:")
                    for ns, ms in sorted_items[:5]:
                        print(f'    "{ns}": "{ms}"')
                    print(f"  ... ({total_items - 10} namespaces más)")
                    print("  Últimos 5:")
                    for ns, ms in sorted_items[-5:]:
                        print(f'    "{ns}": "{ms}"')
                
                # Destacar el namespace recién procesado
                position = list(sorted_json.keys()).index(namespace) + 1
                print(f'\n🎯 Namespace "{namespace}" está en la posición {position} de {total_items}')
                print(f'🔧 Microservicios en "{namespace}": {sorted_json[namespace]}')
                
            except FileNotFoundError:
                print(f"❌ Error: No se pudo encontrar el archivo {cluster_file}")
                sys.exit(1)
            except json.JSONDecodeError as e:
                print(f"❌ Error: Archivo JSON inválido - {e}")
                sys.exit(1)
            except Exception as e:
                print(f"❌ Error inesperado: {e}")
                sys.exit(1)
        
        if __name__ == "__main__":
            main()
        EOF
        
        # Ejecutar el script de Python
        python update_json.py "$CLUSTER_FILE" "$NAMESPACE" "$MICROSERVICE"
        
        # Limpiar archivo temporal
        rm update_json.py
    
    - name: Validate JSON syntax
      run: |
        echo "🔍 Validando sintaxis del JSON..."
        if ! jq empty "${{ steps.validate_cluster.outputs.cluster_file }}"; then
          echo "❌ Error: El archivo JSON tiene sintaxis inválida"
          echo "Restaurando backup..."
          cp "${{ steps.validate_cluster.outputs.cluster_file }}.backup" "${{ steps.validate_cluster.outputs.cluster_file }}"
          exit 1
        fi
        echo "✅ Sintaxis JSON válida"
    
    - name: Show changes
      run: |
        echo "📊 Cambios realizados:"
        echo "Archivo: ${{ steps.validate_cluster.outputs.cluster_file }}"
        echo "Namespace agregado: ${{ inputs.namespace }}"
        echo "Microservicio: ${{ inputs.microservice }}"
        echo ""
        echo "🔄 Diferencias:"
        diff -u "${{ steps.validate_cluster.outputs.cluster_file }}.backup" "${{ steps.validate_cluster.outputs.cluster_file }}" || true
    
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Agregar solo el archivo modificado
        git add "${{ steps.validate_cluster.outputs.cluster_file }}"
        
        # Verificar si hay cambios para commitear
        if git diff --staged --quiet; then
          echo "ℹ️  No hay cambios para commitear"
        else
          git commit -m "feat: Add microservice '${{ inputs.microservice }}' to namespace '${{ inputs.namespace }}' in ${{ inputs.cluster_name }}

          📁 Cluster: ${{ inputs.cluster_name }}
          🏷️  Namespace: ${{ inputs.namespace }}
          🔧 Microservice: ${{ inputs.microservice }}
          🔤 Sorted alphabetically (namespaces and microservices)
          ➕ Preserves existing microservices in namespace
          
          Auto-generated by GitHub Actions"
          
          echo "✅ Cambios commiteados exitosamente"
        fi
    
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}

    - name: Get commit hash
      id: get_commit
      run: |
        # Verificar si hay cambios commiteados
        COMMIT_MESSAGE=$(git log -1 --pretty=%B)
        if [[ "$COMMIT_MESSAGE" == *"feat: Add microservice"* ]] && [[ "$COMMIT_MESSAGE" == *"Auto-generated by GitHub Actions"* ]]; then
          COMMIT_HASH=$(git rev-parse HEAD)
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "📝 Commit hash to cherry-pick: $COMMIT_HASH"
        else
          echo "ℹ️  No se detectaron cambios generados por el action para hacer cherry-pick"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Cherry-pick to main branch
      if: steps.get_commit.outputs.has_changes == 'true'
      id: cherry_pick
      run: |
        echo "🍒 Iniciando cherry-pick a la rama main..."
        
        # Verificar si la rama main existe
        if ! git ls-remote --heads origin main | grep -q main; then
          echo "⚠️  La rama 'main' no existe en el repositorio remoto"
          echo "Saltando cherry-pick..."
          exit 0
        fi
        
        # Fetch todas las ramas remotas
        git fetch origin
        
        # Checkout a main
        git checkout main
        git pull origin main
        
        echo "✅ Cambiado a rama main"
        echo "📋 Últimos commits en main:"
        git log --oneline -3
        
        # Intentar hacer cherry-pick
        if git cherry-pick ${{ steps.get_commit.outputs.commit_hash }}; then
          echo "✅ Cherry-pick exitoso!"
          echo "🎯 Commit aplicado en main: ${{ steps.get_commit.outputs.commit_hash }}"
          
          # Push a main
          git push origin main
          echo "✅ Cambios pusheados a main exitosamente"
          
          echo "cherry_pick_success=true" >> $GITHUB_OUTPUT
        else
          echo "❌ Cherry-pick falló - posiblemente hay conflictos"
          echo "🔧 Resolviendo conflictos automáticamente..."
          
          # Intentar resolver conflictos manteniendo el cambio del commit actual
          git status --porcelain | grep "^UU" | cut -c4- | while read file; do
            echo "🔧 Resolviendo conflicto en: $file"
            # Aceptar la versión del commit que estamos cherry-picking
            git checkout --theirs "$file"
            git add "$file"
          done
          
          # Continuar el cherry-pick si se resolvieron conflictos
          if git cherry-pick --continue; then
            echo "✅ Cherry-pick completado después de resolver conflictos"
            git push origin main
            echo "✅ Cambios pusheados a main exitosamente"
            echo "cherry_pick_success=true" >> $GITHUB_OUTPUT
          else
            echo "❌ No se pudo completar el cherry-pick automáticamente"
            echo "⚠️  Se requiere intervención manual"
            git cherry-pick --abort
            echo "cherry_pick_success=false" >> $GITHUB_OUTPUT
          fi
        fi
      continue-on-error: true
    
    - name: Cleanup backup
      run: |
        rm -f "${{ steps.validate_cluster.outputs.cluster_file }}.backup"
        echo "🧹 Backup eliminado"
    
    - name: Summary
      run: |
        echo "🎉 ¡Proceso completado exitosamente!"
        echo ""
        echo "📋 Resumen:"
        echo "  • Cluster: ${{ inputs.cluster_name }}"
        echo "  • Namespace: ${{ inputs.namespace }}"
        echo "  • Microservicio: ${{ inputs.microservice }}"
        echo "  • Archivo actualizado: ${{ steps.validate_cluster.outputs.cluster_file }}"
        echo ""
        echo "✅ El namespace y microservicio han sido agregados al cluster correctamente."
