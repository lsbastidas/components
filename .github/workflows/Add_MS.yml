name: Add Namespace and Microservice to Cluster

on:
  workflow_dispatch:
    inputs:
      cluster_name:
        description: 'Selecciona el cluster'
        required: true
        type: choice
        options:
          - PDCOLClusterEA01
          - PDCOLClusterEA02
          - PDCOLClusterPosWebEA
          - PDMEXClusterEA
          - PDPTCOLClusterEA
          - QACOLClusterEA
          - QACOLClusterEA02
          - QACOLClusterPosWebEA
          - QAMEXClusterEA
          - QAPTCOLClusterEA
          - STCOLClusterEA
          - STMEXClusterEA
          - STPTCOLClusterEA
          - SiigoAcademico80sCluster
        default: PDCOLClusterEA01
      namespace:
        description: 'Nombre del namespace (ej: siigo-addons)'
        required: true
        type: string
        default: 'siigo-'
      microservice:
        description: 'Nombre del microservicio (ej: api-gateway-addons)'
        required: true
        type: string
        default: 'api-gateway-'

jobs:
  add-namespace-microservice:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Validate cluster file exists
      id: validate_cluster
      run: |
        CLUSTER_FILE=".github/Utils/ms-per-cluster/${{ inputs.cluster_name }}.json"
        if [ ! -f "$CLUSTER_FILE" ]; then
          echo "âŒ Error: El archivo $CLUSTER_FILE no existe"
          echo "Clusters disponibles:"
          ls -la .github/Utils/ms-per-cluster/*.json | awk -F'/' '{print $NF}' | sed 's/.json$//' || echo "No se encontraron archivos JSON"
          exit 1
        fi
        echo "âœ… Cluster file found: $CLUSTER_FILE"
        echo "ðŸ“ Procesando cluster: ${{ inputs.cluster_name }}"
        echo "cluster_file=$CLUSTER_FILE" >> $GITHUB_OUTPUT
    
    - name: Backup original file
      run: |
        cp "${{ steps.validate_cluster.outputs.cluster_file }}" "${{ steps.validate_cluster.outputs.cluster_file }}.backup"
    
    - name: Add namespace and microservice
      id: update_json
      run: |
        CLUSTER_FILE="${{ steps.validate_cluster.outputs.cluster_file }}"
        NAMESPACE="${{ inputs.namespace }}"
        MICROSERVICE="${{ inputs.microservice }}"
        
        # Crear script de Python para manipular el JSON
        cat > update_json.py << 'EOF'
        import json
        import sys
        import os
        from collections import OrderedDict
        
        def main():
            if len(sys.argv) != 4:
                print("âŒ Error: Se requieren 3 argumentos: cluster_file, namespace, microservice")
                sys.exit(1)
            
            cluster_file = sys.argv[1]
            namespace = sys.argv[2]
            new_microservice = sys.argv[3]
            
            try:
                # Leer el archivo JSON
                with open(cluster_file, 'r', encoding='utf-8') as f:
                    json_data = json.load(f)
                
                # Verificar si el namespace ya existe
                if namespace in json_data:
                    existing_microservices = json_data[namespace]
                    print(f"âš ï¸  Namespace '{namespace}' ya existe con microservicios: '{existing_microservices}'")
                    
                    # Separar los microservicios existentes
                    if existing_microservices:
                        microservices_list = [ms.strip() for ms in existing_microservices.split(',')]
                    else:
                        microservices_list = []
                    
                    # Verificar si el microservicio ya existe
                    if new_microservice in microservices_list:
                        print(f"â„¹ï¸  El microservicio '{new_microservice}' ya existe en el namespace '{namespace}'")
                        print("No se realizarÃ¡n cambios.")
                        return
                    
                    # Agregar el nuevo microservicio a la lista
                    microservices_list.append(new_microservice)
                    
                    # Ordenar los microservicios alfabÃ©ticamente
                    microservices_list.sort(key=str.lower)
                    
                    # Crear la cadena de microservicios separada por comas
                    updated_microservices = ', '.join(microservices_list)
                    
                    print(f"âž• Agregando '{new_microservice}' a la lista existente")
                    print(f"ðŸ“ Lista actualizada: '{updated_microservices}'")
                    
                    # Actualizar el namespace con la lista completa
                    json_data[namespace] = updated_microservices
                else:
                    # Si el namespace no existe, simplemente agregarlo
                    print(f"ðŸ†• Creando nuevo namespace '{namespace}' con microservicio '{new_microservice}'")
                    json_data[namespace] = new_microservice
                
                # Ordenar alfabÃ©ticamente por namespace (clave)
                sorted_json = OrderedDict(sorted(json_data.items(), key=lambda x: x[0].lower()))
                
                # Escribir el archivo JSON actualizado (con formato bonito y orden alfabÃ©tico)
                with open(cluster_file, 'w', encoding='utf-8') as f:
                    json.dump(sorted_json, f, indent=2, ensure_ascii=False)
                    f.write('\n')  # Agregar nueva lÃ­nea al final
                
                print(f"âœ… Namespace '{namespace}' procesado exitosamente")
                print(f"ðŸ“ Archivo actualizado: {cluster_file}")
                print(f"ðŸ”¤ Datos ordenados alfabÃ©ticamente (namespaces y microservicios)")
                
                # Mostrar el contenido actualizado (solo los primeros y Ãºltimos elementos para no saturar)
                sorted_items = list(sorted_json.items())
                total_items = len(sorted_items)
                
                print(f'\nðŸ“‹ Contenido actualizado ({total_items} namespaces):')
                if total_items <= 10:
                    # Si hay pocos elementos, mostrar todos
                    for ns, ms in sorted_items:
                        print(f'  "{ns}": "{ms}"')
                else:
                    # Si hay muchos elementos, mostrar los primeros 5 y Ãºltimos 5
                    print("  Primeros 5:")
                    for ns, ms in sorted_items[:5]:
                        print(f'    "{ns}": "{ms}"')
                    print(f"  ... ({total_items - 10} namespaces mÃ¡s)")
                    print("  Ãšltimos 5:")
                    for ns, ms in sorted_items[-5:]:
                        print(f'    "{ns}": "{ms}"')
                
                # Destacar el namespace reciÃ©n procesado
                position = list(sorted_json.keys()).index(namespace) + 1
                print(f'\nðŸŽ¯ Namespace "{namespace}" estÃ¡ en la posiciÃ³n {position} de {total_items}')
                print(f'ðŸ”§ Microservicios en "{namespace}": {sorted_json[namespace]}')
                
            except FileNotFoundError:
                print(f"âŒ Error: No se pudo encontrar el archivo {cluster_file}")
                sys.exit(1)
            except json.JSONDecodeError as e:
                print(f"âŒ Error: Archivo JSON invÃ¡lido - {e}")
                sys.exit(1)
            except Exception as e:
                print(f"âŒ Error inesperado: {e}")
                sys.exit(1)
        
        if __name__ == "__main__":
            main()
        EOF
        
        # Ejecutar el script de Python
        python update_json.py "$CLUSTER_FILE" "$NAMESPACE" "$MICROSERVICE"
        
        # Limpiar archivo temporal
        rm update_json.py
    
    - name: Validate JSON syntax
      run: |
        echo "ðŸ” Validando sintaxis del JSON..."
        if ! jq empty "${{ steps.validate_cluster.outputs.cluster_file }}"; then
          echo "âŒ Error: El archivo JSON tiene sintaxis invÃ¡lida"
          echo "Restaurando backup..."
          cp "${{ steps.validate_cluster.outputs.cluster_file }}.backup" "${{ steps.validate_cluster.outputs.cluster_file }}"
          exit 1
        fi
        echo "âœ… Sintaxis JSON vÃ¡lida"
    
    - name: Show changes
      run: |
        echo "ðŸ“Š Cambios realizados:"
        echo "Archivo: ${{ steps.validate_cluster.outputs.cluster_file }}"
        echo "Namespace agregado: ${{ inputs.namespace }}"
        echo "Microservicio: ${{ inputs.microservice }}"
        echo ""
        echo "ðŸ”„ Diferencias:"
        diff -u "${{ steps.validate_cluster.outputs.cluster_file }}.backup" "${{ steps.validate_cluster.outputs.cluster_file }}" || true
    
    - name: Commit changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Agregar solo el archivo modificado
        git add "${{ steps.validate_cluster.outputs.cluster_file }}"
        
        # Verificar si hay cambios para commitear
        if git diff --staged --quiet; then
          echo "â„¹ï¸  No hay cambios para commitear"
        else
          git commit -m "feat: Add microservice '${{ inputs.microservice }}' to namespace '${{ inputs.namespace }}' in ${{ inputs.cluster_name }}

          ðŸ“ Cluster: ${{ inputs.cluster_name }}
          ðŸ·ï¸  Namespace: ${{ inputs.namespace }}
          ðŸ”§ Microservice: ${{ inputs.microservice }}
          ðŸ”¤ Sorted alphabetically (namespaces and microservices)
          âž• Preserves existing microservices in namespace
          
          Auto-generated by GitHub Actions"
          
          echo "âœ… Cambios commiteados exitosamente"
        fi
    
    - name: Push changes
      uses: ad-m/github-push-action@master
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        branch: ${{ github.ref }}

    - name: Get commit hash
      id: get_commit
      run: |
        # Verificar si hay cambios commiteados
        COMMIT_MESSAGE=$(git log -1 --pretty=%B)
        if [[ "$COMMIT_MESSAGE" == *"feat: Add microservice"* ]] && [[ "$COMMIT_MESSAGE" == *"Auto-generated by GitHub Actions"* ]]; then
          COMMIT_HASH=$(git rev-parse HEAD)
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "has_changes=true" >> $GITHUB_OUTPUT
          echo "ðŸ“ Commit hash to cherry-pick: $COMMIT_HASH"
        else
          echo "â„¹ï¸  No se detectaron cambios generados por el action para hacer cherry-pick"
          echo "has_changes=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Cherry-pick to main branch
      if: steps.get_commit.outputs.has_changes == 'true'
      id: cherry_pick
      run: |
        echo "ðŸ’ Iniciando cherry-pick a la rama main..."
        
        # Verificar si la rama main existe
        if ! git ls-remote --heads origin main | grep -q main; then
          echo "âš ï¸  La rama 'main' no existe en el repositorio remoto"
          echo "Saltando cherry-pick..."
          exit 0
        fi
        
        # Fetch todas las ramas remotas
        git fetch origin
        
        # Checkout a main
        git checkout main
        git pull origin main
        
        echo "âœ… Cambiado a rama main"
        echo "ðŸ“‹ Ãšltimos commits en main:"
        git log --oneline -3
        
        # Intentar hacer cherry-pick
        if git cherry-pick ${{ steps.get_commit.outputs.commit_hash }}; then
          echo "âœ… Cherry-pick exitoso!"
          echo "ðŸŽ¯ Commit aplicado en main: ${{ steps.get_commit.outputs.commit_hash }}"
          
          # Push a main
          git push origin main
          echo "âœ… Cambios pusheados a main exitosamente"
          
          echo "cherry_pick_success=true" >> $GITHUB_OUTPUT
        else
          echo "âŒ Cherry-pick fallÃ³ - posiblemente hay conflictos"
          echo "ðŸ”§ Resolviendo conflictos automÃ¡ticamente..."
          
          # Intentar resolver conflictos manteniendo el cambio del commit actual
          git status --porcelain | grep "^UU" | cut -c4- | while read file; do
            echo "ðŸ”§ Resolviendo conflicto en: $file"
            # Aceptar la versiÃ³n del commit que estamos cherry-picking
            git checkout --theirs "$file"
            git add "$file"
          done
          
          # Continuar el cherry-pick si se resolvieron conflictos
          if git cherry-pick --continue; then
            echo "âœ… Cherry-pick completado despuÃ©s de resolver conflictos"
            git push origin main
            echo "âœ… Cambios pusheados a main exitosamente"
            echo "cherry_pick_success=true" >> $GITHUB_OUTPUT
          else
            echo "âŒ No se pudo completar el cherry-pick automÃ¡ticamente"
            echo "âš ï¸  Se requiere intervenciÃ³n manual"
            git cherry-pick --abort
            echo "cherry_pick_success=false" >> $GITHUB_OUTPUT
          fi
        fi
      continue-on-error: true
    
    - name: Cleanup backup
      run: |
        rm -f "${{ steps.validate_cluster.outputs.cluster_file }}.backup"
        echo "ðŸ§¹ Backup eliminado"
    
    - name: Summary
      run: |
        echo "ðŸŽ‰ Â¡Proceso completado exitosamente!"
        echo ""
        echo "ðŸ“‹ Resumen:"
        echo "  â€¢ Cluster: ${{ inputs.cluster_name }}"
        echo "  â€¢ Namespace: ${{ inputs.namespace }}"
        echo "  â€¢ Microservicio: ${{ inputs.microservice }}"
        echo "  â€¢ Archivo actualizado: ${{ steps.validate_cluster.outputs.cluster_file }}"
        echo ""
        echo "âœ… El namespace y microservicio han sido agregados al cluster correctamente."
